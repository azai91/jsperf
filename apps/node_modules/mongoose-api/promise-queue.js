
/*

The following section is ugly and certainly not prefered
However, I'll try to walk you through this the best I can

1) We add a counter to the instance which will be deleted before saving
  -We expect each part to add to it whenever they succeed
  -We expect each part to subtract whenever they are done
  -Optionally, they can set it to an error (which counts as "throwing it")

2) When the counter === 0, we resolve the promise

*/

var async = require("async");

// receives object instance
module.exports = function(obj,next){
  var tasks = 0;
  var rejected = false;
  var resolved = false;
  var cbs = [];
  var locks = {};
  obj.queueState = {
    pending:function(){
      tasks++;
      return this;
    },
    lock: function(key){
      if(!(key in locks)){
        locks[key] = [];
      }
      return this;
    },
    waitFor: function(key,fn){
      if(!(key in locks)){
        locks[key] = [fn];
      }
      if(locks[key] === true) return fn();
      locks[key].push(fn);
    },
    unlock: function(key){
      if(!(key in locks)){
        locks[key] = true;
        return this;
      }
      var args = Array.prototype.slice.call(arguments,1);
      var ari = locks[key];
      locks[key] = true;
      ari.forEach(function(fn){fn.apply(fn,args);});
      return this;
    },
    error:function(e){
      if(resolved) return console.error("already resolved");
      if(rejected) return console.error("rejecting twice");
      delete obj.queueState;
      rejected = true;
      async.applyEach(cbs,e,next.bind(next,e));
    },
    done: function(){
      if(rejected) return console.log("already rejected");
      if(resolved) return console.error("resolve twice");
      tasks--;
      if(tasks === 0){
        resolved = true;
        delete obj.queueState;
        //Possibly null
        async.applyEach(cbs,void 0,next);
      }
    },
    callback:function(cb){
      cbs.push(cb);
      return this;
    }
  };
};